# docker

## syntax

#### base

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        + ----- client ----- +       + ----------- docker_host ------------ +       + ---- registry --- +
        |                    |       |                                      |       |                   |
        |                    |       |  <======== docker daemon =========>  |       |                   |
        |                    |       |                                      |       |                   |
        |                    |       |  + - containers - +  + - images - +  |       |                   |
        |    docker build    |       |  |                |  |            |  |       |                   |
        |    docker pull     |       |  |                |  |            |  |       |                   |
        |    docker run      |       |  |                |  |            |  |       |                   |
        |                    |       |  + -------------- +  + ---------- +  |       |                   |
        |                    |       |                                      |       |                   |
        + ------------------ +       + ------------------------------------ +       + ----------------- +


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// docker 运行底层原理


docker 比虚拟机更少的抽象层
docker 不需要 Hyoervisor 实现硬件资源虚拟化
docker 容器上的成宿使用的都是实际物理机器的硬件资源( 因此 CPU,内存等 使用率更高 )
docker 利用的是宿主机的内核, 而需要 GuestOS( docker 不要和虚拟机一样重新加载一个操作系统内核 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


docker 可以看作是一个简易版的 linux 环境( 包括 root权限, 进程空间, 用户空间, 网络空间等 )


    - 更轻量: 基于容器虚拟化, 仅包含运行所需的 runtime 环境
    
    - 更高校: 无操作系统虚拟化开销
    
    - 更灵活: 分层储存和包管理, 支持多种网络配置


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// Docker 镜像都是只读的


当容器启动时, 一个新的额可写层被加载到镜像顶部

这一层称为 "容器层", 容器册之下的都称为 "镜像层"


//-------------------------------------------------------------------------------------------------------------------//


// UnionFS


分层, 轻量级且高性能文件系统, 支持对文件修改提交后一层层的叠加
同时可以将不同目录挂载到同一个虚拟文件系统( unite serveral directories into a single virtual )
"Union文件系统" 是 "docker image" 的基础
镜像可以通过分层来继承, 基于尽享

* 特性: 可以同时加载多个文件嵌套系统, 最终文件系统会包含素偶有底层文件和目录


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// Docker 镜像加载原理

docker 镜像实际上由一层一层的文件系统组成, 称为 UnionFS

bootfs( boot file system ) 主要包含: bootloader & kernel & bootloader

    linux 刚启动时会加载 bootfs 文件系统           // docker_image: 最底层是 bootfs 系统
                                                // bootloader 主要加载 kernel 
    
    当 boot 加载完成之后整个内核就在内存中了, 此时内存的使用权已由 bootfs 交给内核, 此时系统会卸载 bootfs


// rootfs( root file system )

包含典型 linux 系统中的 文件及目录

rootfs 就是各种不同操作系统的发行版本


//-------------------------------------------------------------------------------------------------------------------//


// image container data( 容器数卷 ): 数据持久化 + 共享数据 => DockerFile


数据持久化, 完全独立于容器的生存周期, Docker 不会在容器删除时删除其挂载的数据卷

    - 数据卷可在容器之间共享或重用
    
    - 数据卷更改可以直接生效
    
    - 数据卷中的更改不会包含在镜像的更新中
    
    - 数据卷的声明周期一直持续到没有容器使用它为止


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// -v [outer_file_path]:[inner_file_path]: 创建容器内外映射文 件
// :ro === 只读

docker run -itd --name [name] -p [host]:[port] -v [outer_ile]:[inner_file]:or [docker_image]


{   // docker inspect [containerId]

    "Volumes": {
        "Volumes": {
            "/imageContainerPath": "/centosPath"
        }
    }

    "VolumesRW":{ 
        imageContainerPath: true            // 可读写
    }                 

    "hostConfig": {
        "Binds": [
            "/centosPath: /imageContainerPath"
        ]
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### DockerFile

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// DockerFile


step_01: 新建项目文件夹

    mkdir [project]


step_02: 创建 DockerFile

    vi DockerFile


step_03: 根据需要编辑指令文件
    
    FROM 
    
    VOLUME
    
    CMD
    
    ...


step_04: 执行 DockerFile 构建新的 image

    docker build -f [DockerFile] -t [new_name]


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// error: cannot open directory Permission denied

"docker run" 命令中添加  "--privileged=true" 即可


//-------------------------------------------------------------------------------------------------------------------//


// DockerFile

    - 每条保留字指令都必须为大写字母且后面至少需要跟随一个参数

    - 指令从上倒下, 顺序执行

    - # 标示注释

    - 每条指令都会创建一个新的镜像层, 并对镜像进行提交


// DockerFile 的大致流程

    1) docker 从基础镜像运行一个容器
    
    2) 执行一条指令并对容器作出修改
    
    3) 执行类似 "docker commit( 提交一个新的镜像版本 )" 
    
    4) docker 再基于刚提交的镜像运行一个新容器
    
    5) 执行 DockerFile 中的下一条指令, 直到所有指令都执行完


// Docker 运行

    * DockerFile: 软件配置文件                              // 配置
            |
            |   build
           \|/
    * Docker: 软件镜像                                     // 应用( 来源: 仓库, 提交 ... ) 
            |
            |   run
           \|/
    * DockerContainer: 配置文件 + 镜像 => 容器              // 部署 & 运维


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

[keyword]       [description]                                [example]

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


FROM            # 基于那个镜像源                               # FROM sentos
MAINTAINER      # 作者<邮箱>                                  # alpha<xiaodao_92@yeah.net>


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


RUN             # 构建容器需要的命令                            # RUN yun -y install vim

WORKDIR         # 创建容器后, shell 登陆进后的根目录             # /user/alpha

ENV             # 环境变量: 设置的环境变量可在后续指令中使用       # MY_PATH /user/alpha  # 设置环境变量
                                                             # WOKDIR $MY_PATH      # 使用环境变量

VOLUME          # 容器数据卷：设置容器内部文件和宿主环境中一一映射  # VOLUME /centos/foo /docker/foo
                # ( 数据持久化 & 数据保存 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


COPY            # 拷贝宿主环境中的文件到镜像容器中                # COPY /centos/bar /docker/bar

ADD             # 拷贝宿主环境中的文件到镜像容器中                # ADD /centos/bar /docker/bar
                # ( 自动处理 URL 和 解压压缩包 )                # ADD /centos/bar.tar /docker/bar.tar


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


CMD             # 指定镜像容器的启动 命令 & 参数( CMD 会被 docker run 后添加指令参数所替代 )
                # ( DockerFile 中可以有多个 CMD 指令, 但仅有最后一个有效 )

ENTRYPOINT      # 指定镜像容器的启动 命令 & 参数                 # ENTRYPOINT ['/user/alpha/start.sh']
CMD             # 利用 shell 文件启动项目                       # CMD ['/user/alpha/start.sh','run']
                                                              # CMD /user/alpha/start.sh && 


EXPOSE          # 容器向外暴露的端口号                          # EXPOSE 8888


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


ONBUILD         # 当构建一个被继承的 DockerFile 时, 父镜像 在被 子镜像 继承后, 触发父镜像的 onbuild


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 使用 docker build 构建流程
 * 
 * 
 * dockerContainer 的构建是在 Docker引擎 中完成的
 * DockerFile 中 COPY等命令 所需要的文件, 则会通过指定的 "镜像构建上下文" 提供
 */


docker build -f DockerFile -t mycentos:1.0 .                # "-f DockerFile": 默认加载该文件( 可省略 )
                                                            # ".": 指定 "docker镜像构建上下文" 的目录

docker build -t mycentos:1.0 .


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### docker run

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * docker [options] images [ccmmand] [arg]: containerId;        // 启动交互式容器
 * 
 * 
 * -d: 后台运行容器
 * -i: 以交互模式( 启动守护式容器 ), 并返回容器ID
 * -t: 为容器重新分配一个为
 * -p: 指定端口映射
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 守护进程: docker的运行机制: 容器后台运行, 必须有一个相对应的前台运行, 否则该容器会自结束
docker run -d [image]               // 开启守护进程   
docker ps -a                        // 查看容器运行已经退出


// 因设置了 docker 相对应的前台程序, 则 docker 不会自结束
docker run -d [image] /bin/sh -c "while tree; do echo hello; skeep 2 done";


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// image inherit

docker run -itd --volumes-from [father_image]

--volumes-from [father_image]: 容器之间配置信息的继承, 数据卷会一直存在, 持续到没有容器使用该文件
                               继承的文件相当于共享该文件的引用, 就算删除该镜像, 也不会影响其他引用拥有该映射文件的镜像


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### docker ps

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * docker ps [options]
 * 
 * 
 * -a: 正在运行 + 运行历史
 * -l: 最近运行 
 * -n: 最近创建 
 * -q: 只显示容器编号
 * -no-trunc: 不截断输出
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### docker manage process

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 删除所有容器

docker rmi -f $(docker images -qa)
docker ps -a -q | xargs docker rm


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### docker container

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 退出容器

exit;                       // 容器停止退出
ctrl + P + Q;               // 容器不停止退出


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 停止容器

docker stop             // 关机
docker kill             // 拔电源( 强制关机 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 查看容器内进程

docker top [image]


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 产看容器内部细节

docker inspect [imageId]


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 进入容器/执行命令在容器内

// 进入容器命令终端, 不启动新的进程
docker attach [image] === docker exec [image] /bin/bash

// 容器中打开新的终端, 并且可以启动新的进程
docker exec [image] [command]


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 从容器内拷贝数据到容器外
docker cp [imageId] [inner_path] [outher_path]


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### docker logs

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * docker logs [options]
 * 
 * 
 * -t: 加入时间戳
 * -f: 跟随最新的日志打印
 * --tail: 数字显示最后多少条
 */

docker logs -f -t [dockerId]


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### docker rmi

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 删除镜像

docker rmi -f [image]


// 删除容器

docker rm [containerId/containerName] 


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### docker commit 

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * docker commit
 * 
 * 
 * 提交容器副本称为新的镜像
 */


docker commit -m "description" -a "author" [containerId]:[version]


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## install image

#### mysql

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


docker run 
    -p 3306:3306                                        // 端口映射
    --name mysql                                        // 容器命名
    -v /home/mysql/conf:/etc/mysql/conf.d               // 配置文件映射
    -v /home/mysql/logs:/logs                           // 日志文件映射
    -v /home/mysql/data:/var/lib/mysql/data             // 数据文件映射
    -e MYSQL_ROOT_PASSWORD=123456                       // 设置 root 用户密码
    -d mysql:5.6                                        // 运行指定版本


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### redis

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


docker run
    -p 6379:6379
    --name redis
    -v /home/redis/data:/usr/data
    -v /home/redis/conf:/usr/local/etc/redis/redis.conf
    -d redis:3.2 redis-server /usr/local/etc/redis/redis.conf
    --appendonly yes


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


