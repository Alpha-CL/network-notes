# internet theory

#### 互联网协议

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Internet Protocol Suite              // 互联网协议
 * 
 * 
 * 互联网的核心为一系列协议
 * 
 * 这些协议规定了电脑如何连接，组网，数据传输等
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### IP 协议

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * IP 协议                        // 规定网络地址的协议，称为 "IP协议"
 *                               // 
 *                               // 目前广泛采用的是 "IP协议第四版"，简称 IPv4( 该版本规定，网络地址由32个二进制位组成 )
 *                               //
 *                               // 主要作用，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络
 * 
 * 范围: 0.0.0.0 ~ 255.255.255.255
 * 
 * 
 * IP地址 分为两个部分 {            // 无法单独依靠 IP 地址判断，哪些是网络部分，哪些是主机部分
 *                               // 需要借助于 "子网掩码"
 * 
 *      1) 前一部分, 代表 "网路"
 * 
 *      2) 后一部分, 代表 "主机"
 * }
 */


IP 地址分为 四个段，xxx.xxx.xxx.xxx，每个段，都由 8 * { 0 || 1 }  组成

00000000.00000000.11111111.11111111

255.255.255.255                                 // 十进制


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * subnet-mask                      // 子网掩码
 * 
 * 
 * 表示子网络特征的一个参数，形式上等同于IP地址( 也是一个32位二进制数字 )
 * 
 * 但其 网络部分全部为 " 1 "，主机部分全部为 "0"
 */

通过 "子网掩码" 可以判断，任意两个 IP 是否处于同一个子网络中

方法: 将两个 IP地址 与 "子网掩码" 分别进行 "AND运算( 两个数位都为1，运算结果为1，否则为0 )"

     然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * IP 数据包
 * 
 * 
 * 根据 IP协议 发送的数据，及称为 IP数据包
 */


因 "以太数据包" 仅包含  "Mac地址"，并没有 "IP地址" 的数据

在不修改以太网规格的情况下，将 "IP数据包" 直接放入以太数据包的 "数据" 部分，

    
Ethernet-Data: {                    // size < 65515bt


    Head: {
    
        // 主要包括版本、长度、IP地址等信息
    },
    
    Data: {
    
        IP-Data: {                  

            Head: {                 // 20bt < size < 60bt 
            
                // 主要包括版本、长度、IP地址等信息
            },
            
            Data: {                 // size < 1500bt 
            
                // 因以太网数据包的"数据"部分，最长只有1500字节
                // IP数据包 超过了1500字节，则需要分割成几个以太网数据包分开发送
            
                // IP数据包的具体内容
            }
        }
    }
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * IP 地址分类
 * 
 * A，B，C 类: 根据 IP 地址下支持电脑的多少台排列 A > B > C
 * 
 */

    一个 IP 地址分为两个部分: 网络 ID，主机ID


    A 类: 0.0.0.0   ~ 127.255.255.255        ( 一个网络就能约有 1600W+ 台电脑 )
     
    B 类: 128.0.0.0 ~ 191.255.255.255        ( 172.16.0.0 ~  172.31.255.255 )
     
    C 类: 192.0.0.0 ~ 223.255.255.255        ( 192.168.xxx.xxx : 私有网络[ 路由器分配 ] )
    
    D 类: ( 多播地址 )
     
    E 类:


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


```

#### 以太网协议

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Frame                // Head & Data
 * 
 * 
 * 早期，每家公司都有自己的电信号分组方式。
 * 
 * 逐渐地，一种叫做 "以太网"( Ethernet )的协议，占据了主导地位
 */


Frame {                 // 以太网规定，一组电信号构成一个数据包，叫做 Frame( 帧 )
                        // 每一帧分成两个部分: Head( 标头 ) 和 Data( 数据 )


    Head: {             //  size = 18 bt 
    
        // 包含数据包的一些说明项，比如发送者、接受者、数据类型等等
    
    },
    
    
    Data: {             // 46 bt < size < 1500 bt
        
        // 数据包的具体内容
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### MAC 地址

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Mac Address              // 定位网卡和数据包的路径
 * 
 * 
 * 发送者和连接者 根据 MAC地址 传送数据
 */


以太网规定，连入网络的所有设备，都必须具有 "网卡接口"

数据包必须是从 "一块网卡" 传送到 "另一块网卡"

网卡的地址，就是数据包的发送地址和接收地址，称为 "MAC地址"


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * MAC 地址规则
 * 
 * 
 * 每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示
 */


MAC Addrress:   00-B0-D0-86-BH-F3
                
                - 前 6 位: 6 个十六进制数为厂商编号
                
                - 后 6 位: 厂商的网卡流水号


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 广播

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 通过 "ARP协议" 比对 Mac-address 判断是否要接收数据
 * 
 * 
 */

1) 以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方
   而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方

2) 子网络所有计算机接收到 Mac-Address 后进行比对
   如果两者相同，则接收这个包，否则就丢弃这个包

3) 此中传播方式称为: "Broadcasting"


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * ARP 协议
 * 
 * 
 * 通过 "APR协议"，可以获取同一个子网络内的主机的 MAC地址，可以将数据包发送到同一子网络内的任意一台主机
 * 
 * 
 ** IP数据包( 对方的 Mac地址 & 对方的 IP ) 通常是放在以太网数据包里发送的
 */


/**
 * 获取 "Mac地址"
 * 
 * 
 * 1) 处于不同子网络: 只能把数据包传送到两个子网络连接处的 "网关"( gateway )，让网关去处理
 * 
 * 
 * 2) 处于同一子网络: - 通过 "ARP协议"，获取对方的 "Mac地址"
 *                  
 *                  - APR协议 将包含 "以太网数据"( 其中包含查找所需主机的 IP地址 )发送给同一子网中的其他主机
 *                    对方的 MAC地址: FF:FF:FF:FF:FF:FF ( 表示该地址为 "广播" )
 * 
 *                  - 处于同一子网中的每台主机，都会收到这个数据包
 *                  
 *                  - 收到该数据包后，会将 "该数据包中的IP地址" 和 "自身的IP地址" 比对
 *                    若两者IP地址相同，则都作出回复
 *                    若两者IP地址不同，则丢弃这个包
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 域名 && DNS 解析

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 域名 -> DNS 解析 -> IP 地址
 * 
 * 域名 && IP 地址: 捆绑关系
 */
 
// 从浏览器请求地址可能出现的解析或缓存流程

浏览器地址输入"域名" --> 浏览器缓存 <= "对应 IP 地址"

                   --> 电脑 hosts 文件 <= "对应 IP 地址"
                  
                   --> 路由器缓存 <= "对应 IP 地址" 
                   
                   --> 上层路由器 <= "对应 IP 地址" ... --> 城市级路由器( Load DNS ) <= "对应 IP 地址"
                   
                   --> ... ---> Global DNS 服务器 <= "对应 IP 地址"
                   
                   
                   * 绝大多数 路由器 或 DNS 解析器 会有缓存 对应 IP 的功能，以便于后续请求时，直接返回 "对应 IP 地址"



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 五层网络模型

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                    Request Start

            + --------------------- +           + --------------------- +       // 应用层( HTTP / DNS Pact )
            |                       |           |                       |       // 
  User ---- |   Application Layer   |           |   Application Layer   |       // [
            |     ( Browser )       |           |    ( Web Server )     |       //    Head: { Ethernet, IP, UDP/TCP }, 
            |                       |           |                       |       //    Data: { all } 
            |                       |           |                       |       // ] 
            |                       |           |                       |       // 
            + --------- | --------- +           + --------- | --------- +       // 规定应用程序的数据格式
                        |                                   |
                        |                                   |
            + --------- | --------- +           + --------- | --------- +       // 传输层( TCP / UDP Pact )
     + ---- |                       |           |                       |       // 建立 "端口到端口" 的通信
     |      |   Transport Layer     |           |   Transport Layer     |       // [
     |      |                       |           |                       |       //    Head: { Ethernet, IP, UDP/TCP }, 
     |      |                       |           |                       |       //    Data: { all } 
     |      |                       |           |                       |       // ] 
     |      |                       |           |                       |       // 
     |      + --------- | --------- +           + --------- | --------- +       // 根据相应的端口与服务器传送数据
                        |                                   |
  operating system      |                                   |
                        |                                   |
     |      + --------- | --------- +           + --------- | --------- +       // 网络层( IP Address && IP Pact )
     |      |                       |           |                       |       // 建立 "主机到主机" 的通信
     |      |   Internet Layer      |           |   Internet Layer      |       // [
     + ---- |                       |           |                       |       //    Head: { Ethernet, IP }, 
            |                       |           |                       |       //    Data: { all } 
            |                       |           |                       |       // ] 
            |                       |           |                       |       // 
            + --------- | --------- +           + --------- | --------- +       // 根据 IP协议区分是否属于同一子网，再利用 MAC地址 传送数据
                        |                                   |
                        |                                   |
            + --------- | --------- +           + --------- | --------- +       // 链接层( Mac Address & Ethernet Pact )
     + ---- |                       |           |                       |       // 
     |      |   Data link Layer     |           |   Data link Layer     |       // [
     |      |                       |           |                       |       //    Head: { Ethernet },  
     |      |                       |           |                       |       //    Data: { all }
     |      |                       |           |                       |       // ]  
     |      |                       |           |                       |       //
     |      + --------- | --------- +           + --------- | --------- +       // 规定电信号分组方式，可以通过 MAC地址 在子网中传送数据 
                        |                                   |
 Operator               |                                   |
                        |                                   |
     |      + --------- | --------- +           + --------- | --------- +       // 物理层( 0101 )
     |      |                       |           |                       |       // 
     |      |   Physical layer     -------------->  Physical layer      |       // [ 0101 0010 0110 ... ]
     + ---- |                       |           |                       |       //
            + --------------------- +           + --------------------- +       // 通过物理手段将电脑连接起来，负责传送电信号
                
                                                         Analyze Start


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 层与协议
 * 
 * 
 * 每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则( "协议" protocol )
 * 
 * 互联网的每一层，都定义了很多协议。这些协议的总称，就叫做"互联网协议"( Internet Protocol Suite )
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 应用层                      // Top
 * 
 * 
 * 接收 "数据传输层" 的数据，规定应用程序的数据格式
 * 
 * HTTP 协议，DNS 协议
 */


[ Ethernet-Head + IP-Head + UDP/TCP-Head + Data ]


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * HTTP 协议
 * 
 * -> Request                   // 请求
 * 
 *      -> Request Header       // 请求头
 *      -> Request Body         // 请求体
 * 
 * -> Response                  // 响应
 * 
 *      -> Response Header      // 响应头
 *      -> Response Body        // 响应体
 */


// Request Header

    ( Request Methods: GET / POST ... ) + ( Request Path: ) + ( Request Pact: HTTP / HTTPS 1.1[ version number ] )
    
      基于外部网络环境中 GET: 参数在 url 中 / POST: 传送文件 ( 理论上不区分方式，因基于外部网络环境和好区分对数据的操作方式 )
    
    Host:                       // 域名
    
    Connection:                 // 链接方式
    
    User-Agent:                 // 用户客户端信息( 杂乱: 历史遗留问题( 浏览器大战 )  )
    
    Accept:                     // 允许接受的格式
    
    Accept-Encoding:            // 允许接受的编码类型
    
    Accept-Language:            // 允许接受的语言类型
    
    Cookie:                     // 缓存密钥
    
    ...


// Response Header

    ( Request Pact: HTTP / HTTPS 1.1[ version number ] + ( Active Code ) + ( Message )
    
    Cache-Control:              // 请求缓存的时间
    
    Connection:                 // 返回数据方式
    
    Content-Length:             // 返回数据长度
    
    Content-Type:               // 返回数据类型
    
    Date:                       // 数据接收时间
    
    Expires:                    // 数据过期时间
    
    Location:                   // 本地地址
    
    Server:                     // 服务器名称
    
    ...


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 传输层                      // 建立 "端口到端口" 的通信
 *                            //
 *                            // 相比之下，"网络层"的功能是建立 "主机到主机" 的通信
 *                            // 只要确定主机和端口，我们就能实现程序之间的交流
 *                            //
 *                            // Unix系统就把主机+端口，称为 "socket( 套接字 )"
 * 
 * 
 * TCP 协议，UDP 协议
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 传输层的由来
 * 
 * 
 * 当有了 Mac地址 和 IP地址，我们则可以在互联网上任意两台主机上建立通信
 * 
 * 但是，在一边浏览网页，一边微信聊天时，一个数据包从互联网发送过来时
 * 
 * 该如何分别是 "浏览网页的数据" 还是 "微信聊天的数据" 呢
 */


/**
 * port             // 端口: 每一个使用网卡的程序的编号
 * 
 * 
 * 每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据
 */

port [0, 65535]     // 正好16个二进制位


1) 0~1023 的端口被系统占用，用户只能选用大于1023的端口

2) 无论是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * UDP 协议
 * 
 * 
 * 在数据包中加入端口信息，这就需要新的协议，UDP协议 几乎就是在数据前面，加上端口号
 * 
 * 
 * 优点: 比较简单，容易实现
 * 
 * 缺点: 可靠性较差，一旦数据包发出，无法知道对方是否收到
 */


/**
 * TCP 协议                   // 为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度
 *                           // 以确保单个TCP数据包不必再分割
 * 
 * 
 * 非常复杂，但可以近似认为，它就是 "有确认机制" 的 UDP协议
 * 
 * 每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包
 * 
 * 
 * 优点: 可以确认每个发出的数据包是否收到
 * 
 * 缺点: 非常复杂
 */


UDP/TCP-Data: {             // 整个 UDP数据包 放入 IP数据包 的 "数据" 部分
                            // IP数据包 又是放在 以太网数据包 之中
                            //
                            // size < 65535 正好放进一个IP数据包


    Head: {             // size = 8bt
    
        // 主要定义了发出端口和接收端口
    },
    
    Data: {
    
        // 具体的内容
    }
}


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 网络层
 * 
 * 
 * IP 地址，IP 协议
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 网络层的由来
 * 
 * 
 */

理论上，单单依靠 MAC地址，上海的网卡 就可以找到 洛杉矶的网卡了，技术上是可以实现的

但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一 "包"，不仅效率低，而且局限在发送者所在的子网络

如果两台计算机不在同一个子网络，广播 是传不过去的


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * "网络层"的诞生         // "网络层"出现以后，每台计算机拥有两种地址，一种是 "MAC地址"，另一种是 "网络地址"
 *                      // 两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，属于随机组合在一起
 * 
 * 
 * 引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络
 * 
 * 网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 数据链路层
 * 
 * 
 * 单纯的 0 和 1 没有任何意义，必须规定解读方式: 多少个电信号算一组? 每个信号位有何意义?
 * 
 * 用于确定 ( 0 & 1 的分组方式 )
 */

通过以下方式，可以将数据在 "同一子网络内" 互相传送
    
    - 数据包的定义( Frame: { Head & Data } )
    
    - 网卡的MAC地址
    
    - 以 "广播" 的形式传送数据


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 物理层                      // Bottom
 * 
 * 
 * 将电脑通过物理手段连接起来，通过光缆、电缆、双绞线、无线电波等方式
 * 
 * 主要规定网络电器特性( 负责传送 0 & 1 的电信号 )
 */

                     computer1 -> 010100011001 ... -> computer2 
                     
                                  0: 低电平
                                  1: 高点平
    + ------------- +                                            + ------------- +
    |               |                                            |               |
    |               |                                            |               |
    |   computer1  ------------------------------------------------  computer2   |
    |               |                                            |               |
    |               |                                            |               |
    + ------------- +                                            + ------------- +
                            
                     * 光纤，铜 ... ( 因导电性能不同影响电信号传输速率率 )
                     
                       不同介质传输的频率不同          



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Get && Post 请求方式的区别

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 是基于什么前提？
 * 
 * 
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 如果什么前提都没有，不使用任何规范，只考虑语法和理论上的 HTTP 协议
 * 
 * 
 */

GET 和 POST 几乎没有什么区别，只有名字不一样


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 如果基于 RFC 规范
 * 
 * 
 */

理论上( Specification ): GET 和 POST 具有相同的语法 ( 语义不同: GET[ 获取 ] / POST [ 发送 ] )

实际上( Implementation ): 各种浏览器，就是这个规范的实现者
                         
    URL 中是否显示: GET 数据显示在 URL 中，POST 请求不显示在 URL 中
    
    数据长度: GET ( URL 的长度是有限的 )，POSt 中 URL 的长度是无限的
    
    是否能当作书签保存: GET 请求的数据可以收藏为 书签，POST 请求的数据 不可收藏为 书签
    
    GET 请求后，按 后退 & 刷新 等按钮无影响，POST 数据请求后会被重新提交
    
    编码类型: GET 编码类型: applicatioon/x-wwww/form-url，
    
             POST 编码类型( 很多种 ): encodeapplication/x-www-form-urlencoded( 加密 )
                                    
                                    multipart/form-data( 文件 )
    
    GET 的历史参数会被保存在浏览器中，POST 的历史浏览参数不会被保存在浏览器中
    
    编码类型: GET 只允许 ASC II 编码，POST 没有编码限制( 允许发 二进制 等 )
    
    安全性: GET 与 POST 相比，GET 安全性较差( 因为如果所发数据中有密码则可能有一部暴露在 URL 中 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### B / S && C / S 结构

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * B / S 结构
 * 
 * 
 */

Browser / Serveer: Browser 只负责内容展示，Serveer 负责提供内容


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * C / S 结构
 * 
 * 
 */

Client / Server： Client 只负责内容展示，Client 负责提供内容 


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * html 页面，本质是什么
 * 
 * 
 */

页面的本质是 字符串，带有 HTML 格式的 字符串


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 网络请求的流程
 * 
 * 
 */


1) 地址栏中输入: www.baidu.com

2) 服务器收到请求: 读取指定请求页面的文件

3) 服务器读取存放请求页面的 HTML 文件

4) 服务器将读取的请求内容返回给 浏览器


* 最后返回的字符串( 可能来源是文件，可能是缓存，可能来自于数据库 )


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 服务器
 * 
 * 本质: 计算机 
 */

严格意义: 服务器是一台计算机，这台计算机，只提供服务


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 服务容器( 日常说的服务器，多指服务容器 )
 * 
 * 本质: 程序
 */

服务容器是一个程序，用于监听端口，读取文件，并且返回

* 一个程序对应一个端口


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 网络资源请求的方式

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


1) 在浏览器中直接输入网址                                                                  // 无法用代码控制

2) Location.href = "url"; 可以发出请求，但页面发生跳转                                      // 页面会跳转

3) 带有 src 属性的标签，请求可以发出，服务端可以处理并返回，但是返回后是否被应用取决于浏览器        // 页面无法处理返回结果

4) 带有 href 属性的标签，请求可以发出，服务端可以处理并返回，但是返回后是否被应用取决于浏览器       // 页面无法处理返回结果

5) 带有 action 属性的标签( form 表单 )，可以发出请求，但页面发生跳转                           // 页面会跳转

...

=> 希望有一种方式: 可以用代码控制，页面不会跳转，服务端返回的结果可以用 JS 继续处理                // Ajax


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 创建 Ajax => 
 *
 *            new XMLHttpRequest();                         // Except IE6
 * 
 *            new ActiveXObject("Microsoft.XMLHttp");       // IE6
 */


var xhr = new XMLHtttpRequest();                            // 除 IE6 以外的浏览器都支持

var xhr = new ActiveXObject("Microsoft.XMLHttp");           // IE6 专属 ajax


=> 兼容代码 

var xhr = null

if (window.XMLHttpRequest) {

    xhr = new XMLHtttpRequest();

} else {

    xhr = new ActiveXObject("Microsoft.XMLHttp");
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 请求要素
 * 
 * Request Method: Get / Post
 * 
 * Request Address: string
 * 
 */


xhr.open(method ,address): result;

xhr.send();


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 跨域访问

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 允许被跨域请求的资源
 * 
 * 
 */

1) js，css，jpg，png 等文件允许被跨域

2) src 属性的资源都允许被跨域

3) href 属性资源大部分都可以被跨域


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 会触发跨域请求的资源
 * 
 * 
 */

1) 后端接口的数据

2) 其他域的 Cookie

3) 其他域的 缓存


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 什么是其他域 ? 怎么样算跨域 ?
 * 
 * 网页: 协议( https / http )，域名，端口 ...
 * 
 */

eg: CurrentPage: locallhost:8080/TestNewWork/Test.html

    RequestDate: http://www.baidu.con:80                        // 默认 80 端口

=> '协议'，'域名'，'端口' 其中任意一个不同，则称为跨域


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 跨域出现在哪个阶段 ?
 * 
 * 
 * 浏览器接收数据后，会判断当前页面和请求页面的域是否一致
 * 
 * 若不一致，接收的数据则不会传递给后续代码处理
 */

1) 即使跨域: 请求也可以发出

2) 即使跨域: 服务器端仍可以 接收，处理，并 返回数据

3) 即使跨域: 浏览器也可以接收到服务器返回的数据

4) 判定跨域: 浏览器接收数据后，发现当前页面的域和请求的域不同，则判定为 '跨域'

5) 判定跨域则不传递数据: 因浏览器判定跨域，即使接收到数据，也不会把数据传递给后续代码进行处理


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 解决跨域( 跨域后，仍需请求这个数据 )
 * 
 * 
 */

// 1. 后端配合，一起解决进行跨域

eg: pan.baidu.com -> zhidao.baidu.com               // 跨域


    1) JSONP( 正常情况，返回数据是 JSON 数据格式，JSONP 是一种特殊的格式 )
    
    
        RequestDataMehod: http://www.test.com:80/test.html

        originBackData => {"status":"ok","msg":"hello world!"}
        
        
        RequestDataMehod: http://www.test.com:80/test.html?callback=jsonp
        
        jsonpBackData => jsonp({"status":"ok","msg":"hello world!"});
        

    2) 后端设置 Access-Control-Allow-Origin 属性，以支持跨域
    
        Response Header {
        
            Access-Control-Allow-Origin: *          // 允许任何域访问
        
        }


// 2. 后端不配合，如何解决进行跨域


    1) <iframe src=""></iframe> 标签引入数据          // 只能显示，不能控制
    
    2) 通过后端代理( 自己的后端 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


